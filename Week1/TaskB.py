"""
СБОР ПОСЫЛОК

На складе есть робот и 𝑛 посылок, которые он хочет собрать. Склад можно представить в виде координатной сетки. Изначально робот находится в точке (0,0). 𝑖-я посылка находится в точке (𝑥𝑖,𝑦𝑖). Гарантируется, что в одной точке не могут находиться две посылки. Также гарантируется, что в точке (0,0) посылки нет.
Робот наполовину сломан и может передвигаться только вверх ('U') и вправо ('R'). Другими словами, за один шаг робот может переместиться из точки (𝑥,𝑦) в точку (𝑥+1,𝑦) или в точку (𝑥,𝑦+1). Как сказано выше, робот хочет собрать все 𝑛 посылок (в любом порядке). Он хочет сделать это за минимально возможное число шагов. Если существует несколько подходящих последовательностей шагов, робот хочет выбрать лексикографически минимальный путь.
Строка 𝑠 длины 𝑛 лексикографически меньше, чем строка 𝑡 длины 𝑛 если существует такой индекс 1≤𝑗≤𝑛, что для всех 𝑖 от 1 до 𝑗−1 𝑠𝑖=𝑡𝑖 и 𝑠𝑗<𝑡𝑗. Это обычное сравнение строк, например, в словаре строки расположены в лексикографическом порядке. Большинство языков программирования сравнивают строки именно так.
"""

t = int(input())
for _ in range(t):
    a = [[0] * 1002 for i in range(1002)]
    n = int(input())
    res = ""
    for i in range(n):
        xi, yi = map(int, input().split())
        a[xi][yi] = 1
    x = 0 
    y = 0 
    flag = 0
    res = ""
    while True:
        if sum(a[x]) >= 1:
            y += 1
            res += "U"
            if a[x][y] == 1:
                n -= 1
                a[x][y] = 0
        else:
            x += 1
            res += "R"
            if a[x][y] == 1:
                n -= 1
                a[x][y] = 0
        if n == 0:
            flag = 1
            break
        elif x == 1001 or y == 1001:
            break
    if flag == 0:
        print("NO")
    else:
        print("YES")
        print(res)
